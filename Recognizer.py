# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N8SP4JT9OUk9g_wexzMlHtMhNVSOAE8D
"""

import cv2
import numpy as np
from tensorflow import keras

def numbers_extract(image_file: str, out_size=28):
    img = cv2.imread(image_file)
    img_extended = cv2.copyMakeBorder(img, 10,10,10,10, cv2.BORDER_CONSTANT)
    gray = cv2.cvtColor(img_extended, cv2.COLOR_BGR2GRAY)
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 199,0) 
    img_erode = cv2.erode(thresh, np.ones((3, 3), np.uint8), iterations=1)

    contours, hierarchy = cv2.findContours(img_erode,  cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    output = thresh.copy()

    numbers = []

    for idx, contour in enumerate(contours):
        (x, y, w, h) = cv2.boundingRect(contour)

        if hierarchy[0][idx][3] == 0:
            cv2.rectangle(output, (x, y), (x + w, y + h), (255, 0, 0), 0)
            number_crop = thresh[y:y + h, x:x + w]
            size_max = max(w, h)
            number_square = 255*np.ones(shape=[size_max, size_max], dtype=np.uint8)

            if w > h:
                y_pos = size_max//2 - h//2
                number_square[y_pos:y_pos + h, 0:w] = number_crop
            elif w < h:
                x_pos = size_max//2 - w//2
                number_square[0:h, x_pos:x_pos + w] = number_crop
            else:
                number_square = number_crop

            numbers.append((x, w, cv2.resize(number_square, (out_size, out_size), interpolation=cv2.INTER_LINEAR)))

    numbers.sort(key=lambda x: x[0], reverse=False)

    return numbers

mnist_labels = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57]

def mnist_predict_img(model, img):
    img_arr = np.expand_dims(img, axis=0)
    img_arr = img_arr.reshape((1, 28, 28, 1))
    img_arr = 1 - img_arr/255.0
    result = model.predict_classes([img_arr])

    return chr(mnist_labels[result[0]])

def img_to_str(model: numbers_extract, image_file: str):
    numbers = numbers_extract(image_file)
    s_out = ""

    for i in range(len(numbers)):
        dn = numbers[i+1][0] - numbers[i][0] - numbers[i][1] if i < len(numbers) - 1 else 0
        s_out += mnist_predict_img(model, numbers[i][2])
        
    return s_out
    
if __name__ == "__main__":
   
    model = keras.models.load_model('/content/model.h5')

print('Enter path to image: ')
img_file = input()
s_out = img_to_str(model, img_file)
print(s_out)

